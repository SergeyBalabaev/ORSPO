# Task093 - typeof

## Теория

В стандарте **C23** появилась поддержка оператора `typeof`, который позволяет получить тип выражения или типа, заданного явно. Это долгожданное дополнение, которое уже много лет было доступно как расширение в компиляторах GCC и Clang, а теперь стало частью официального стандарта языка.

## Основные возможности

### `typeof(выражение)`
Возвращает тип указанного выражения, не вычисляя его. Например:
```c
int x = 42;
typeof(x) y = 10;        // y имеет тип int
typeof(x + 3.14) z;      // z имеет тип double (результат приведения)
```

### `typeof(тип)`
Можно напрямую указать имя типа:
```c
typeof(int) a;           // a — int
typeof(int*) p;          // p — int*
```

### `typeof_unqual`
Этот вариант ведёт себя аналогично `typeof`, но удаляет квалификаторы верхнего уровня: `const`, `volatile`, `restrict` и атомарность.
```c
const int ci = 5;
typeof(ci) x = ci;       // x имеет тип const int
typeof_unqual(ci) y = ci; // y имеет тип int (без const)
```

## Применение

1. **Объявление переменных «того же типа»**  
   Полезно для написания универсальных макросов, где нужно повторить тип переданного аргумента.
   ```c
   #define SWAP(a, b) do { \
       typeof(a) tmp = (a); \
       (a) = (b);          \
       (b) = tmp;          \
   } while (0)
   ```

2. **Совместно с `_Generic`**  
   Можно реализовать обобщённые функции без макросов, явно указывая тип через `typeof`.
   ```c
   #define PRINT(x) _Generic((x), \
       int: print_int,            \
       double: print_double       \
   )(x)
   ```

3. **Упрощение сложных объявлений**  
   Если тип выражения громоздкий, можно использовать `typeof`, чтобы не повторять его:
   ```c
   int (*func_ptr)(double, char);
   typeof(*func_ptr) another_func; // another_func — функция, принимающая double и char, возвращающая int
   ```

4. **Создание временных объектов того же типа, что и аргумент макроса**  
   Например, в макросе `MAX` для избежания двойного вычисления аргументов:
   ```c
   #define MAX(a, b) ({ \
       typeof(a) _a = (a); \
       typeof(b) _b = (b); \
       _a > _b ? _a : _b;  \
   })
   ```

## Зачем это нужно в C23?

Ранее для подобных целей программисты использовали либо макросы с неявным предположением о типах, либо расширения компиляторов. Стандартизация `typeof` делает код более переносимым и читаемым, особенно в системном программировании и при реализации сложных макросов.

## Задание

### Задание 1
Напишите макрос SWAP(a, b), который обменивает значения двух переменных любого типа. Используйте typeof для создания временной переменной нужного типа. Учтите, что макрос не должен вычислять аргументы более одного раза.

### Задание 2

Дан фрагмент кода:
```c
const int ci = 10;
volatile int vi = 20;
const volatile int cvi = 30;
```

С помощью `typeof` и `typeof_unqual` объявите три новые переменные (x, y, z), которые будут содержать те же значения, но не иметь квалификаторов const и volatile. Присвойте им соответствующие значения и измените их (например, x = 100;), чтобы убедиться, что квалификаторы сняты.

### Задание 3

Используя `_Generic` и `typeof`, реализуйте макрос PRINT_VALUE(val), который выводит значение в зависимости от его типа:
- для int — через printf("%d", val)
- для double — через printf("%f", val)
- для char* — через printf("%s", val)
- для остальных типов — через printf("unknown type")