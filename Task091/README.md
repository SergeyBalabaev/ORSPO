# Task091 — Переменное число аргументов

## Теория

В С11 определён новый тип макросов – макросы с переменным числом параметров. Определяется он похоже на функции с переменным числом параметров. Обращение к параметрам происходит через макрос `__VA_ARGS__`. `__VA_ARGS__` заменяется на переданные аргументы. Пример: имеется функция, собирающая односвязный список из массива.
```c
typedef struct Node {
    int value;
    struct Node *next;
} Node;
 
void push(Node **head, int data) {
    Node *tmp = (Node*) malloc(sizeof(Node));
    tmp->value = data;
    tmp->next = (*head);
    (*head) = tmp;
}
 
int pop(Node **head) {
    Node* prev = NULL;
    int val;
    if (head == NULL) {
        exit(-1);
    }
    prev = (*head);
    val = prev->value;
    (*head) = (*head)->next;
    free(prev);
    return val;
}
 
void fromArray(Node **head, int *arr, size_t size) {
    size_t i = size - 1;
    if (arr == NULL || size == 0) {
        return;
    }
    do {
        push(head, arr[i]);
    } while(i--!=0);
}
```

Необходимо написать макрос, который бы собрал список, при этом количество параметров можно было изменять.

Функция fromArray получает три аргумента – указатель на узел, массив и его размер. Мы хотим избавиться от размера и массива. Тем не менее, всё равно придётся передавать тип массива, чтобы автоматически можно было изменять его размер.
```c
#define fromArr(list, type, ...) {\
        type xname[] = {__VA_ARGS__};\
        fromArray(&list, xname, (sizeof(xname)/sizeof(type)));\
}
```

Макрос принимает два обязательных параметра – имя узла и название типа. Оставшихся параметров будет произвольное число, они перечисляются через запятую.
```c
type xname[] = {__VA_ARGS__};\
```

внутри блока (области, ограниченной фигурными скобками) создаём массив и инициализируем его. При этом длина массива определяется автоматически.
```c
fromArray(&list, xname, (sizeof(xname)/sizeof(type)));\
```

Вызываем функцию, передавая ей в качестве аргументов указатель на узел, массив, который мы только что создали и размер. Так как тип массива известен и массив статический, то количество элементов находится элементарно.

Вызов
```c
Node *head = NULL;
fromArr(head, int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
```

таким образом, будет трансформирован в
```c
{
        int xname[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
        fromArray(&head, xname, (sizeof(xname)/sizeof(int)));
}
```

## Задание

Возьмите какой-нибудь код из предыдущих заданий и попробуйте переписать часть логики на макросы с перменным колличеством аргументов. Добейтесь того, чтобы вся логика сохранилась и программа работала корректно.
