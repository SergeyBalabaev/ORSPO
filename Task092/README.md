# Task092 — `_Generic`

## Теория

Обобщения или generics представляют универсальные функции или типы, которые не зависят от используемых в них типов данных (еще называется параметрическим полиморфизмом). Нативно язык Си не поддерживает обобщения. Однако благодаря макросам можно до некоторой степени имитировать подобную функциональность. Кроме того, начиная со стандарта C11 был добавлен специальный макрос _Generics, который мозволяет упростить определение обобщений.

Сначала посмотрим, как что-то наподобие универсальных функций и типов-структур мы могли бы сделать с помощью обычных макрос и для этого возьмем простейший пример - сложение чисел разных типов:
```c
#include <stdio.h>
 
#define define_sum(T) T sum_##T(T a, T b) {\
 return a + b; \
}
 
#define sum(T) sum_##T
 
define_sum(int)
define_sum(float)
 
int main(void)
{
    printf("float: %f\n", sum(float)(3.0, 2.0));
    printf("int: %d\n", sum(int)(3, 2));
    return 0;
}
```

Здесь определено два макроса. Первый макрос - define_sum(T) предназначен для определения функции сложения:
```c
#define define_sum(T) T sum_##T(T a, T b) {\
 return a + b; \
}
```
Через параметр T будет передаваться тип данных. С помощью оператора ## название типа будет присоединяться к названию функции sum. Например, если в макрос передается тип "int", то будет определяться функция "sum_int". Для переноса кода макроса на последующие строки применяется слеш \

Второй макрос устанавливает вызов определенной функции:
```c
#define sum(T) sum_##T
```

Например, первый вызов макроса define_sum:
```c
define_sum(int)
```
разворачивается в следующий код:
```c
int sum_int(int a, int b) {
 return a + b;
}
```

При вызове второго макроса - "sum(T)" будет происходить вызов функции:
```c
printf("int: %d\n", sum(int)(3, 2));
```
то есть фактически мы получим код:
```c
printf("int: %d\n", sum_int(3, 2));
```


Аналогично можно создавать псевдоуниверсальные структуры:
```c
#include <stdio.h>
 
#define DEFINE_PERSON(T, N) struct Person_##N{\
    T id;\
    char name[20];\
};
 
DEFINE_PERSON(int, int)
DEFINE_PERSON(char*, char)
 
#define person(N) struct Person_##N
 
 
int main(void)
{
    person(char) tom = {.id="regjh12345", .name="Tom"};
    person(int) bob = {.id=12344, .name="Bob"};
 
    printf("id: %s  name: %s\n", tom.id, tom.name);
    printf("id: %d  name: %s\n", bob.id, bob.name);
    return 0;
}
```

В данном случае макрос `DEFINE_PERSON` разворачивается в структуру, где тип поля id зависит параметра макроса, через который передается тип данных. Первый параметр макроса указывает на тип поля id, а второй параметр служит для установки уникального имени структуры. Например, при вызове макроса `DEFINE_PERSON(char*, char)` мы получим определение следующей структуры:
```c
struct Person_char{
    chr* id;
    char name[20];
};
```

## Макрос _Generic

В стандарт C11 был добавлен макрос _Generic, который позволяет в ряде случаев уйти от жесткой привязки к типам данных в выражениях. Этот макрос при компиляции на основании типа данных выбирает нужную реализацию выражения. Он имеет следующее определение:
```c
_Generic (контролирующее_выражение, список_ассоциаций)
```
Первый параметр или контролирующее_выражение представляет выражение, тип которого будет сравниваться с типами из второго параметра - списка ассоциаций

Второй параметр или список_ассоциаций представляет список разделенных запятыми сопоставлений типов и выражений в следующем виде:
```c
тип1 : выражение1,
тип2 : выражение2,
default : выражение по умолчанию
```
Тип из контролирующего выражения сравнивается с типами из списка списка ассоциаций, и если совпадение найдено, то выполняется определенное выражение.


Рассмотрим на примере. Допустим, нам надо, чтобы у нас была функция, которая складывает два числа. Но при этом эти два числа могли представлять различные типы:
```c
#include <stdio.h>
 
// определение обобщенной функции sum
#define sum(a, b) _Generic((a), \
    int : sum_int, \
    float : sum_float, \
    default : sum_double \
)(a, b)
 
// отдельные реализации функции
void sum_int(int a, int b)
{
    printf("Sum of ints: %d\n", a + b);
}
void sum_float(float a, float b)
{
    printf("Sum of floats: %f\n", a + b);
}
void sum_double(double a, double b)
{
    printf("Sum of numbers: %lf\n", a + b);
}
int main(void)
{
    int int_num1 = 4;
    int int_num2 = 5;
 
    float float_num1 = 5.6f;
    float float_num2 = 6.5f;
 
    double double_num1 = 2.3l;
    double double_num2 = 3.7l;
 
    sum(int_num1, int_num2);
    sum(float_num1, float_num2);
    sum(double_num1, double_num2);
     
    return 0;
}
```

Вначале определяем обобщенную функцию `sum()`, которая не будет привязана конкретным типам:
```c
#define sum(a, b) _Generic((a), \
    int : sum_int, \
    float : sum_float, \
    default : sum_double \
)(a, b)
```

Здесь `sum(a, b)` указывает, что функция будет называться "sum" и будет принимать два параметра.

Далее идет применение макроса _Generic. В качестве контролирующего выражение в нем используется выражение (a). То есть будет использоваться тип данных параметра a, который передается в функцию sum.

Затем определяется список ассоциаций - `int : sum_int`, `float : sum_float`, `default : sum_double`. То есть если параметр a представляет тип int, то в качестве реализации функции `sum()` в реальности будет использоваться функция `sum_int()`. Если тип параметра float, то выбирается функция sum_float. Во всех остальных случаях выбирается функция `sum_double()`.

Далее в скобках указываются параметры для вызова выбранной функции: `(a, b)`

После определения обобщенной функции sum() определяются конкретные реализации, которые будут использоваться в зависимости от типа данных:
```c
void sum_int(int a, int b)
{
    printf("Sum of ints: %d\n", a + b);
}
void sum_float(float a, float b)
{
    printf("Sum of floats: %f\n", a + b);
}
void sum_double(double a, double b)
{
    printf("Sum of numbers: %lf\n", a + b);
}
```

И в функции main вызываем функцию sum(), передавая ей значения определенного типа. А на основании типа первого параметра будет выбираться конкретная реализация:
```c
sum(int_num1, int_num2);
sum(float_num1, float_num2);
sum(double_num1, double_num2);
```
То есть мы вызываем функцию sum(), но за кадром в реальности вызывается функция, предназначенная для определенных типов.

Консольный вывод:
```
Sum of ints: 9
Sum of floats: 12.100000
Sum of numbers: 6.000000
```

## Задание

### Описание задачи

Напишите программу на C, демонстрирующую работу с _Generic. Программа должна содержать реализацию нескольких обобщённых макросов и их тестирование. Обязательные пункты:

1) Макрос PRINT_VALUE(x)
    Выводит значение x в зависимости от его типа:
    - Для целых типов (int, short, long и т.п.) — как целое число (printf("%d") или "%ld" в зависимости от размера). Можно ограничиться int и long.
    - Для чисел с плавающей точкой (float, double) — как число с плавающей точкой (%f).
    - Для строк (char*) — как строку (%s).
    - Для указателей (кроме char*) — как адрес (%p).
    - Для остальных типов — сообщение "unsupported type".

2) Макрос MAX(x, y)
    Обобщённый макрос, возвращающий максимум двух чисел. Должен работать для любых числовых типов (int, double и т.д.) и сохранять тип результата (т.е. для двух int возвращать int, для double — double). Учтите случай, когда типы x и y различаются — в этом можно либо приводить к общему типу (повышение), либо выдавать ошибку компиляции. Для простоты можно потребовать, чтобы типы совпадали.

3) Макрос IS_INTEGER(x)
    Макрос, который раскрывается в 1, если x имеет целый тип (включая char, short, int, long и их unsigned варианты), и в 0 в противном случае. Используйте _Generic с ассоциациями для целых типов, возвращающими 1, и default: 0.

4) Макрос FORMAT_SPECIFIER(x)
    Макрос, который возвращает строковый литерал с соответствующим спецификатором формата для printf: для целых — "%d" (или "%ld"), для double — "%f", для char* — "%s", для указателей — "%p". Демонстрация: напечатать значение, используя этот спецификатор (можно вместе с PRINT_VALUE, но отдельно).

### Требования к реализации
- Программа должна быть написана на чистом C, соответствующем стандарту C11 или новее (включите флаг -std=c11 при компиляции).
- Используйте _Generic именно для диспетчеризации по типу, а не перегрузку через макросы с разными именами.
- Код должен быть хорошо прокомментирован, особенно макросы с _Generic, чтобы объяснить, как работает выбор.
- Предусмотрите обработку потенциальных проблем: например, для PRINT_VALUE для целых можно использовать _Generic с несколькими целыми типами, но для упрощения можно ограничиться int и double и строкой.
- Продемонстрируйте, что макросы работают с литералами и переменными соответствующих типов.