# Task085 — Текстовые файлы

## Основы

Файл в языке Си рассматривается как неструктурированная последовательность байтов. С этой точки зрения в языке программирования C (как и в unix подобных ОС) файлом может быть как собственно файл на жестком диске, так и принтер, дисплей и другие подключаемые устройства ввода-вывода.

Как правило, взаимодействие между приложением и файлами производится посредством обмена блоков байт фиксированной длины (обычно длина представляет степень двойки).

При чтении из файла данные помещаются в буфер операционной системы, а затем побайтно передаются приложению.

При записи в файл данные накапливаются в буфере, а при заполнении буфера записываются на диск в виде единого блока байт.

Буферы представляют участки памяти, поэтому передача данных между приложением и буфером происходит довольно быстро в отличие от взаимодействия с физическими устройствами типа принтера.

Файл вместе с предоставляемыми средствами буферизации представляет поток.

Язык программирования Си содержит необходимый функционал для работы с файлами и устройствами ввода-вывода. Для применения его применения в программе необходимо подключить заголовочный файл `stdio.h`.

## Открытие и закрытие потоков

### Открытие файла

Чтобы работать с потоком, его необходимо открыть. Для открытия потока применяется функция fopen(), которая имеет следующий прототип:
```c
FILE * fopen(имя_файла, режим_открытия);
```

Первый параметр представляет имя открываемого файла, а второй задает режим открытия, от которого зависит, как файл может быть обработан.

Функция возвращает указатель на структуру, которая имеет тип `FILE`, определенный в том же файле `stdio.h`. Этот указатель идентифицирует поток в программе и через него мы сможем обращаться к открытому файлу.
При открытии поток связывается со структурой

Режимы открытия

Каждый режим задается в виде набора символов. В частности, мы можем использовать следующие режимы:
- "**w**": текстовый файл открывается для записи. Если файл ранее существовал, то он пересоздается и записывается заново
- "**r**": текстовый файл открывается для чтения
- "**a**": текстовый файл открывается для добавления в него новых данных. Если файл существовал ранее, то данные просто добавляются
- "**w+**": текстовый файл создается для записи/записи. Если файл ранее существовал, то при первой записи после открытия он пересоздается и записывается заново. А при последующих записях после открытия данные добавляются в него без перезаписи.
- "**r+**": текстовый файл открывается для чтения/записи. Запись допустима в любом месте файла, кроме конца файла, то есть недопустимо увеличение размеров файла.
- "**a+**": текстовый файл открывается или создается (при его отсутствии) для чтения/записи. В отличие от режима w+ файл при открытии не пересоздается заново, а в отличии от режима r+ можно записывать данные в конец файла
- "**wb**": бинарный файл открывается для записи
- "**rb**": бинарный файл открывается для чтения
- "**ab**": бинарный файл открывается для дозаписи
- "**w+b**": бинарный файл создается для записи/чтения
- "**r+b**": бинарный файл открывается для чтения/записи
- "**a+b**": бинарный файл открывается или создается (при его отсутствии) для чтения/дозаписи

Режимы позволяют разграничить доступ к файлу и открыть его только для чтения или только для записи или совместить оба варианта. Кроме того, на уровне режимов происходит разделение файлов на текстовые и бинарные. И программа будет обрабатывать файлы определенным образом, в зависимости какой режим будет выбран - для текстовых или бинарных файлов. Неправильно заданный режим может привести к некорректной интерпретации файла.

### Закрытие файла

После завершения работы с файлом его следует закрыть. Для этого применяется функция fclose():
```c
int fclose(указатель_на_поток);
```

Единственный параметр функции представляет ранее полученный при открытии файла указатель на структуру `FILE`, связанный с файлом.

Функция возвращает число: 0 - в случае успешного выполнения и встроенное значение EOF в случае ошибки.

Например, откроем и закроем файл "data.txt", который расположен в одной и той же папке, что и выполняемая программа:
```c
#include <stdio.h>
 
int main(void)
{
    FILE * fp = fopen("data.txt", "w");
    fclose(fp);
    return 0;
}
```

Если файл расположен в каком-то другом месте, то можно указать соответствующий относительный или абсолютный путь. Например, `/home/user/data.txt`.

## Обработка ошибок

В процессе открытия или создания файла мы можем столкнуться с рядом ошибок, например, при открытии в режиме чтения не окажется подобного файла, недостаточно памяти и т.д. И в случае возникновения ошибки функция fopen() возвращает значение NULL. Мы можем обработать возникновение ошибки с помощью проверки результата функции:
```c	
#include <stdio.h>
  
int main(void)
{
    FILE * fp= fopen("data28.txt", "r");
    if(fp==NULL)
    {
        perror("Error occured while opening data28.txt");
        return 1;
    }
     
    fclose(fp);
    return 0;
}
```

Для вывода ошибки на консоль применяется встроенная функция perror(). И так как дальнейшие действия в программе в случае ошибки при открытии файла смысла не имеют, то с помощью вызова `return 1;` завершаем работу приложения и возвращаем число, отличное от нуля (обычно ненулевое число рассматривается как код ошибки).

И если при попытке открытия файла по указанному пути его не окажется, то консоль выведет следующую ошибку:
`Error occured while opening data28.txt: No such file or directory`

## Символьное чтение и запись из/в файл

### Символьная запись в файл

```c
int fputs(const char *str, FILE *stream)
```

Функция `fputs()` записывает содержимое строки, на которую указывает `str`, в заданный поток. Нуль в конце строки не записывается.

В случае успеха функция `fputs()` возвращает последний записанный символ, а в случае неудачи EOF. Если поток открыт в текстовом режиме, могут иметь место некоторые преобразования сим­волов. Это значит, что строка может быть переписана в файл не «один к одному». Если же поток открыт в двоичном режиме, то преобразования символов нет и строка переписывается в файл «один к одному».


### Символьное чтение из файл

```c
char *fgets(char *str, int num, FILE *stream)
```

Функция `fgets()` считывает до num-1 символов из файла stream и помещает их в массив символов, на который указывает str. Символы считываются до тех пор, пока не встретится символ «новая строка», EOF или до достижения указанного предела. По окончании считывания в массив str сразу после последнего считанного символа помещается нулевой символ. Символ «новая строка» при считывании будет сохранен и станет частью массива str.

В случае удачи `fgets()` возвращает str, при неудаче возвращается NULL. В случае ошибки по чтению содержимое массива, на который указывает str, не определено. Поскольку как в случае ошибки, так и при достижении конца файла возвращается null, для определения того, что имен­но произошло, необходимо использовать `feof()` или `ferror()`.


## Форматированный вывод

Функция fprintf() имеет следующий прототип:
```c
int fprintf( FILE * stream, const char * format, ... );
```
или если объяснять попроще:
```c
int fprintf(указатель_на_поток, строка_форматирования, список_аргументов);
```

Эта функция записывает данные, передаваемые в качестве третьего параметра, в файл с учетом форматирования, определяемого строкой форматирования. Первый параметр представляет указатель на файловый поток, в который производится запись.

Строка форматирования и передача в нее значений определяются также, как и в случае с функцией `printf()`

## fopen_s - новая и ~~не слишком~~ `безопасная` реализация открытия файла

С приходом стандарта C11 пришла и новая `безопасная` функция открытия файла:
```c
errno_t fopen_s( FILE * streamptr, const char filename, const char  mode );
```

Новая версия `fopen` отличается от старой синтаксисом. Теперь указатель на открытый файл нужно получать посредством передачи в аргументы функции заранее объявленного указателя типа `FILE`.

Смысл ее существования? Ну, вокруг этого в интернете много спорят до сих пор. Минимальная проверка на NULL указатели в аргументах в новой функции есть. 

Использовать ее вместо классического `fopen`? Наверное стоит. Как минимум она есть в стандарте C11 и это уже о чем-то говорит. В коде к заданиям мы будем использовать именно ее.

## Задание

Вам дан файл `work_with_files.c`. Изучите его, сопоставьте используемые там инструкции с теми, что были описаны в теории выше. Поймите, что каждая из них делает, какой результат возвращает и какое действие выполняет.

Перед запуском кода создайте в рабочей директории файл с именем `data.txt`. Запустите код и поработайте с ним. Попробуйте что-то записать в файл и потом запустить программу. Объясните увиденное.
